//트리(tree)의 개념 : 개층적(hierarchical structure)인 관계를 표현하고 싶은 경우 사용되는 구조

//결정트리(decision tree) : 인간의 의사 결정 구조를 표현하는 한가지 방법
//노드(node) : 한 개 이상의 노드들로 이루어진 유한 집합
//루트(root) : 계층적인 구조에서 가장 높은 곳에 있는 노드
//서브트리(subtree) : 그 왜 나머지 노드
//간선(edge) : 루트와 서브트리의 연결 선
//노드들간의 관계는 부모, 형제, 조상 자손 인간의 관계와 동일하다.
//부모노드(parents node)
//자식노드(children node)
//형제관계(sibling)
//조상노드(ancestor node) : 루트 노드에서 임의의 노드까지의 경로를 이루고 있는 노드
//자손노드(descendent node) : 임의의 노드 하위에 연결된 모든 노드,
//즉, 어떤 노드의 서브트리에 속하는 모든 노드들
//단말노드(terminal node) : 자식노드가 없는 노드
//비단말노드(nonterminal node) : 자식노드가 있는 노드
//차수(degree) : 어떤 노드가 가지고 있는 자식 노드의 개수
//단말노드는 차수가 0인 노드이다.
//트리의 차수 : 트리가 가지고 있는 노드의차수 중에서 가장 큰 차수.
//레벨(level) : 트리의 각 층에 번호를 매기는 것으로 정의하여 루트 레벨은 1일되고
//한 층씩 내려갈수록 1씩 증가한다.
//트리의 높이(height) : 트리가 가지고 있는 최대 레벨
//포리스트(forest) : 나무가 모이면 숲이 되듯, 트리의 집합을 말한다.

//[트리의 종류]
//각 노드가 데이터를 필드와 자식 노드를 가리키는 링크 필드를 가지게 한다.
//1. 일반적인 트리 : 각 노드들은 서로 다른 개수의 자식 노드를 가지므로 링크 필드의 개수가 달라진다.
//문제점 : 노드의 크기가 고정되지 않는다.
//즉, 노드에 붙어있는 서브트리의 개수에 따라서 노드의 크기가 커지기도 하고 작아지기도 한다.

//2. 이진트리
//트리 중 가장 많이 쓰이는 트리가 이진트리이다.
//이진트리(binary tree) : 모든 노드가 2개의 서브 트리를 가지고 있는 트리
//1 서브트리는 공집합 일 수 있다. 따라서 이지 ㄴ트리의 노드에는 최대 2개까지의
//자식 노드가 존재 할 수 있고 모든 노드의 차수는 2이하가 된다.
//2 서브트리간의 순서가 존재한다. 따라서 왼쪽 서브트리와 오른쪽 서브트리로 서로 구별한다.

//[이진트리와 일반 트리의 차이점] (표)
//				이진트리							일반트리
//차수			자식노드의 개수가 2이하		자식 노드 갯수의 제한이 없음
//노드			공집합 포함						노드를 가진다.
//서브트리	 서브트리간의 순서 존재			서브트리간의 순서 존재하지 않음

//[이진트리 종류]
//1. 포화이진트리 : 각 레벨에 노드가 꽉 차 있는 이진트리
// 일반으로 포화 이진트리에서의 노드의 개수는 2 ^ K - 1과 같이 계산된다.
// 레벨 단위로 왼쪽에서 오른쪽으로 각 노드에 번호를 붙일 수 있다.
// 즉, 루트 노드의 오른쪽 자식 노드의 번호는 항상 3이다.
//2. 완전이진트리 : 높이가 K일때 레벨 1부터 K - 1까지는 노드가 모두 채워져있고,
// 마지막 레벨 K에서는 왼쪽에서부터 오른쪽으로 노드가 순서대로 채워져 있는
// 이진트리이다.
// 마지막 레벨에서는 높이가 꽉 차있지 않아도 되지만 중간에 빈 곳이 있어서는 안된다.
// 따라서, 포화 이진트리에서는 항상 완전이진트리지만, 그 역은 항상 성립하지 않는다.
//3. 기타 이진트리


//[배열 표현법]
//-주로 포화 이진트리나 완전 이진트리의 경우 많이 쓰이는 방법
// 완전이진트리의 번호대로 노드들을 저장한다.
// 노드들은 먼저 번호가 매겨진 다음, 이 번호에 따라서 배열이 저장된다.
// 인덱스 0은 계산을 복잡하게 하기 때문에 사용되지 않는다.
// 일반이진트리의 경우 배열표현법을 사용하면 저장은 가능하지만 기억공간의 낭비가 심해진다.

// 배열표현법에서는 인덱스만 알면 노드의 부모나 자식을 쉽게 알 수 있다.
// -노드 i의 부모 노드 인덱스 = i / 2
// -노드 i의 왼쪽자식 노드 인덱스 = 2i
// -노드 i의 오른쪽자식 노드 인덱스 = 2i + 1

//[링크 표현법]
// 노드가 구조체로 표현되고, 각 노드가 포인터를 가지고 있어서 이 포인터를 이용하여
// 노드와 노드를 연결하는 방법
// 하나의 노드가 데이터를 저장하는 필드와 왼쪽 자식노드와 오른쪽 자식노드를
// 가리키는 2개의 포인터를 가진다. 포인터를 이용해서 부모노드와 자식노드를 연결한다.

// [이진트리의 순회]
// 순회(traversal) : 이진트리의 속하는 모든 노드를 한번씩 방문하여 노드가
// 가지고 있는 데이터를 목적에 맞게 처리하는 것
// 트리가 가지고 있는 자료를 순차적으로 순회하는 것은 이진트리에서 중요한 연산이다.

// [이진트리의 순회방법 3가지]
// -항상 왼쪽 서브트리를 오른쪽 서브 트리에 앞서서 방문한다고 가정한다.
// -서브 트리에 들어있는 노드들도 순회 순서데로 순회한다.
//1. 전위 순회(preorder traversal) : VLR
// : 루트를 먼저 방문하고 그 다음 왼쪽 서브 트리를 방문하고 오른쪽 서브 트리를 마지막으로
// 방문하는 것
//	1. 루트 노드를 방문한다.
//	2. 왼쪽 서브트리를 방문한다.
//	3. 오른쪽 서브트리를 방문한다.

//2. 중위 순회(indorder traversal) : LVR
// : 먼저 왼쪽 서브트리, 루트, 오른쪽 서브 트리 순으로 방문한다.
//	1. 왼쪽 서브트리를 방문한다.
//	2. 루트 노드를 방문한다.
//	3. 오른쪽 서브트리를 방문한다.

//3. 후위 순회(postorder traversal) : LRV
// : 왼쪽 서브트리, 오른쪽 서브트리, 루트 순으로 방문한다.
//	1. 왼쪽 서브트리의 모든 노드를 방문한다.
//	2. 오른쪽 서브 트리의 모든 노드를 방문한다.
//	3.루트 노드를 방문한다.
 

// [전위, 중위, 후위 순회의 선택방법] 
// 만일 순서는 중요하지 않고 노드를 전부 방문 하기만 한다면
// 3가지 방법 중에 어느 것이건 관계없다.
// 그러나 자식 노드를 처리한 다음에 부모 노드를 처리해야 한다면
// 후위 순회를 사용하여야 하고, 부모 노드를 처리한 다음에 자식 노드를
// 처리해야 한다면 전위 순회를 사용해야 한다.
// 예를 들어 디렉토리의 용량을 계산하려면 후위 순회를 사용하여야 한다.
// 하위 디렉토리의 용량이 계산되어야만 현재의 디렉토리 용량을 계산 할 수 있다.

//4. 레벨순회(level order) : 각 노드를 레벨 순으로 검사하는 순회 방법이다.
// 동일한 레벨의 경우에는 좌에서 우로 방문한다.
// 레벨 순회는 큐를 사용하는 순회 방법이다.
// 큐에 하나라도 노드가 있으면 계속 반복하는 코드로 이루어져있다.
// 먼저 큐에 있는 노드를 꺼내어 방문한 다음 -> 그 노드의 자식 노드를 큐에 삽입
// 하는 것으로 반복을 끝낸다. 이러한 반복을 큐에 더 이상의 노드가 없을 때 까지 계속한다.
