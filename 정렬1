//정렬(sorting) : 오름차순이나 내림차순으로 나열하는 것을 의미한다.
//일상생활에서 많이 사용되며, 자료탐색에 있어서 필수적이다.
//일반적으로 정렬시켜야 할 것은 레코드이다.
//레코드는 다시 필드라고 하는 데, 작은 단위로 나누어진다.
//학생의 레코드는 이름, 학번, 주소, 연락처 등이 필드가 될 것이다.
//특히 레코드와 레코드를 식별해주는 역할을 하는 필드를 key라고 한다.
//학생 코드의 경우에는 학번이 키가 될 수 있다.
//정렬 알로리즘을 평가하는 효율성의 기준 : 비교 연산의 횟수와 이동연산의 횟수
//일반적으로 이동 횟수와 비교 횟수가 서로 비례하지 않는다.
//즉 어떤 알고리즘은 비교 횟수는 많지만 이동 횟수는 적을 수도 있고 또 그 반대도 가능하다.
//숫자와 숫자를 비교하는 것은 시간이 걸리지 않지만 문자열과 문자열을 비교하는 것은
//상당히 시간이 걸리는 작업이다.
//또 숫자를 이동시키는 것은 간단하지만 큰 구조체를 이동시키려면 상당한 시간이 걸릴 것이다.
//현재 개발중인 응용에 맞추어서 가장 적절한 정렬 알고리즘을 선택해야 한다.
//내부정렬 : 모든 데이터가 주기억장치에 저장된 상태에서 정렬하는 것.
//외부정렬 : 외부기억장치(하드디스크)에 대부분의 데이터가 있고 일부만 주기억장치에
//저장되어 있는 상태에서 정렬을 하는 방법
//안정성 : 입력 데이터가 동일한 키 값을 레코드가 여러개 존재할 경우,
//이들 레코드들의 상대적인 위치가 정렬 후에 위치가 바뀌었으므로 안정하지 않은 정렬의 예이다.
//안정성을 충족하는 삽입, 합병 정렬 등을 사용해야 한다.

//1. 선택정렬(selection sort) : 먼저 왼쪽 리스트와 오른쪽 리스트가 있다고 가정하고,
//왼쪽리스트에는 정렬이 완료된 숫자들이 들어있고 오른쪽 리스트에는 정렬되지 않은 숫자들이 들어있다.
//왼쪽 리스트는 비어있고 정렬 되어야 할 숫자들은 모두 오른쪽 리스트에 들어있다.
//가장 작은 숫자를 오른쪽 리스트에서 선택하여 왼쪽 리스트로 이동하는 작업을 되풀이 한다.
//오른쪽 리스트가 공백 상태가 될 때까지 이 과정을 되풀이 하는 정렬기법이다.
//입력 배열과는 별도로 똑같은 크기의 배열이 하나 더 필요하지만, 이렇게 입력 배열 이외에는 다른 추가 메모리리를
//요구하지 않는 정렬 방법을 제자리 정렬(in-place sorting)이라고 한다.

//[선택정렬의 과정]
//입력배열에서 최솟값을 배열을 첫번째 요소와 교환한다.
//다음에는 첫번째 요소를 제외한 나머지 요소들 중에서 가장 작은 값을 선택하고
//이를 두번째 요소와 교환한다.
//이 절차를(숫자개수 -1)만큼 되풀이 하면 추가적인 배열을 사용하지 않고서도 전체 숫자들이 정렬된다.

//2. 삽입정렬(insertion sort) : 손안의 카드를 정렬하는 방법과 유사하다.
//정렬되어 있는 리스트에 새로운 레코드를 올바른 위치에 삽입하는 과정을 반복한다.
//선택 정렬과 마찬가지로 입력 배열을 정렬된 리스트와 정렬되지 않은 리스트로 나누어 사용하면 된다.
//정렬되어 있지 않은 리스트의 첫번째 숫자가 정렬된 리스트의 어느 위치에 삽입되어야 하는가를 판단한 후
//해당 위치에 이 숫자를 삽입하게 되면, 정렬된 리스트의 크기는 하나 커지게 되고,
//정렬이 되지 않은 리스트의 크기는 하나 줄어들게 된다.
//이러한 삽입 연산을 정렬되지 않은 리스트가 없어질때까지 반복하게 되면 전체 리스트가 정렬된다.
//삽입정렬 알고리즘
//1) 인덱스 1부터 시작한다. 인데스 0은 이미 정렬된 것으로 볼 수 있다.
//2) 현재 삽입 될 숫자인 i번째 정수를 key변수로 복사
//3) 현재 정렬된 배열은 i - 1까지 이므로 i - 1번째부터 역순으로 조사한다.
//4) j값이 음수가 아니어야 되고 key값보다 정렬된 배열에 있는 값이 크면
//5) j번째를 j + 1번째로 이동한다.
//6) j를 하나 감소한다.
//7) j번째 정수가 key보다 작으므로 j + 1번째가 key값이 들어갈 위치이다.

//3. 버블정렬(bubble sort) : 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어있지 않으면 서로 교환하는
//비교 - 교환 과정을 리스트의 왼쪽 끝에서 시작해서 오른쪽 끝까지 진행한다.
//이러한 리스트의 비교 - 교환 과정이 한번 완료되면 가장 큰 레코드가 리스트의 오른쪽 끝으로 이동된다.
//버블정렬 알고리즘
//먼저 하나의 스캔은 j = 0부터 j = i - 1까지 반복하는 루프로 구성되고 j번째 요소와
//j + 1번째 요소를 비교하여 크기순으로 되어있지 않으면 교환한다.
//i는 하나의 스캔이 끝날 때마다 1씩 감소한다.
//이런 스캔 과정이 n - 1번 되풀이 되면 정렬이 끝나게 된다.

//#define SWAP(x, y, t)((t)=(x), (x)=(y), (y)=(t))
//void selection_sort(int list[], int n) {
//	int i, j, least, temp;
//	for (j = i + 1; j < n; j++) { //최솟값 탐색
//		if (list[j] < list[least]) least = j;
//	}
//	SWAP(list[i], list[least], temp);
//}

//#include <stdio.h>
//#include <stdlib.h>
//#define MAX_SIZE 10000
//#define SWAP(x,y,t)((t)=(x), (x)=(y), (y)=(t))
//
//int list[MAX_SIZE];
//int n;
//
//void selection_sort(int list[], int n) {
//	int i, j, least, temp;
//	for (i = 0; i < n - 1; i++) {
//		least = i;
//		for (j = i + 1; j < n; j++) //최솟값 탐색
//			if (list[j] < list[least]) least = j;
//		SWAP(list[i], list[least], temp);
//	}
//}
//void main() {
//	int i;
//	n = MAX_SIZE;
//	for (i = 0; i < n; i++) //난수 생성 및 출력
//		list[i] = rand() % n; //난수 발생 범위 0~n
//	selection_sort(list, n); //선택정렬 호출
//	for (i = 0; i < n; i++)
//		printf("%d\n", list[i]);
//}

//삽입정렬
//void insertion_sort(int list[], int n) {
//	int i, j, key;
//	for (i = 1; i < n; i++) {
//		key = list[i];
//		for (j = i - 1; j >= 0 && list[j] > key; j--)
//			list[j + 1] = list[j]; //레코드의 오른쪽 이동
//		list[j + 1] = key;
//	}
//}

//#define SWAP(x, y, t)((t)=(x), (x)=(y), (y)=(t))
//void bubble_sort(int list[], int n) {
//	int i, j, temp;
//	for (i = n - 1; i > 0; i--) {
//		for (j = 0; j < i; j++)
//			//앞뒤의 레코드를 비교한 후 교체
//			if (list[j] > list[j + 1])
//				SWAP(list[j], list[j + 1], temp);
//	}
//}
